The gas costs of adding a member and of donating to the contract are lower than those of the given contract.

	|=================================================|
	|-------------------------------------------------|
	|Adding a member:	Before		Now               |
	|-------------------------------------------------|
	|transaction cost	231421 gas	25275 gas         |
	|execution cost		208741 gas	 2595 gas         |
	|                                                 |
	|												  |
	|-------------------------------------------------|
	|Donating to the contract:	Before		Now       |
	|-------------------------------------------------|
	|transaction cost:			92211 gas	21792 gas |
	|execution cost:			70939 gas	  520 gas |
	|=================================================|

Намерени "anti-pattern"-и:
--------------------------
1. В конструктора на MemberContr инициализацията трябва да стане през конструктора на Member
	member = Member({adr: adr, joinedAt: now, fundsDonated: 0});
2. Променливите tmp1,tmp2,tmp3 са декларирани като state променливи на контракта, а трябва да са декларирани вътре в modifier-а "onlyMember" (по принцип по надолу ще опиша и защо не трябва да ги има въобще)
3. Изтриваме memberList - не се използва и няма нужда от него понеже никъде в условието не се иска да могат да се изведат всички member-и
4. Правим MemberContr да е библиотека и сменяме името да е MemberLib и преправяме Membered контракта да работи с нея.Логиката от конструктора я местим в нова функция - "init".
5. Добавяме assert за проверка дали не сме препълнили стойността на uint256
	assert(self.fundsDonated>=value);
6. Трием get() метода понеже няма да го ползваме вече в onlyMember
7. Добавяме проверка "require(self.adr == address(0));" в "init" функцията, която проверява дали даденият адрес вече съществува
8. Местим проверката дали дарената сума е > 0 в "donated" функцията на MemberLib библиотеката
9. Във функцията init махаме "self.fundsDonated = 0;" защото by default началната стойност му е толкова
